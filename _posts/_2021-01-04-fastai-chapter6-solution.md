---
toc: true
layout: post
comments: true
description: Ответы на шестую часть Fast.ai Deep Learning 2020
categories: [markdown, fastai, Russian, Deep Learning]
title: Russian - Fastbook Chapter 6 questionnaire solutions
---
Ответы на русском языке на [вопросы](https://forums.fast.ai/t/fastbook-chapter-6-questionnaire-solutions-wiki/69922) к шестой части курса Deep Learning 2020 на Fast.ai. Если есть притензии к переводу, как и к осталььным частям прошу писать в коментариях - поправлю.

**1. Как множественная классификация может улучшить медвежий классификатор?**

Позволило бы классифицировать отсутствие медведей. В противном случае модель множественной классификации будет предсказывать присутствие медведя, даже если его там нет (если только явно не добавлен отдельный класс).

**2. Как мы кодируем зависимую переменную в задаче классификации с несколькими метками?**

Кодируется как one-hot encoded вектор. По сути, это означает, что у нас есть нулевой вектор одинаковой длины числу классов с единицой с индексом соответствующего класса.

**3. Как получить доступ к строкам и столбцам DataFrame, как если бы это была матрица?**

Вы можете использовать *.iloc*. Например, *df. iloc\[10,10\]* выберет элемент в 10-й строке и 10-м столбце, как если бы DataFrame был матрицей.

**4. Как получить столбец по имени из DataFrame?**

Это очень просто. Вы можете просто использовать указатель. Пример: *df\['column_name'\]*

**5. В чем разница между Dataset и DataLoader?

Dataset-это набор, который возвращает кортеж независимой и зависимой переменной для одного элемента. DataLoader - это функционально расширеный Dataset. Это итератор, который обеспечивает поток мини-пакетов, где каждый мини-пакет представляет собой пару пакетов из независимых и зависимых переменных.

**6. Что обычно содержиться в Dataset?**

Обучающий и проверочный набор.

**7. Что обычно содержит DataLoader?**

Тренировочный и проверочный dataloader.

**8. Что обычно лямбда делает в Python?

Лямбды-это сокращенный вариант для написания функций (написание однострочных функций). Он отлично подходит для быстрого прототипирования и итерации, но поскольку он не сериализуем, его нельзя использовать в развертывании и производстве.

**9. Каковы методы настройки того, как независимые и зависимые переменные создаются с помощью API блоков данных?**

*get_x* and *get_y*
* get_x используется для указания способа создания независимых переменных.
* get_y используется для указания того, как маркируются точки данных

**10. Почему softmax не является подходящей функцией активации для вывода при использовании one hot encoded целевого значения?**

Softmax нужно, чтобы модель предсказывала только один класс, что может быть неверно в задаче многоклассовой классификации. В задачах классификации с несколькими метками входные данные могут иметь несколько меток или даже не иметь меток.

**11. Почему nll_loss не является подходящей функцией потерь при использовании one hot encoded целевого значения?

Опять же, nll_loss работает только тогда, когда модели нужно предсказать только один класс, чего здесь нет.

**12. В чем разница между nn.BCELoss и nn.BCEWithLogitsLoss?**

nn.BCELoss не включает в себя начальную сигмоиду. Предполагается, что соответствующая функция активации (т.е. сигмовидная) уже была применена к предсказаниям. nn.BCEWithLogitsLoss с другой стороны применяет и сигмоиду и кросс-энтропию в одной функции.

**13. Почему мы не можем использовать обычную точность(accurancy) в задаче с несколькими метками?**

Обычная точнасть предполагает, что конечным предсказанным моделью классом является класс с наибольшей активацией. Однако в задачах с несколькими метками может быть несколько меток. Поэтому порог для активаций должен быть установлен для выбора конечных прогнозируемых классов на основе активаций по сравнению с целевыми классами.

**14. Когда это нормально, чтобы настроить гипер-параметр в проверочном наборе?**

Это нормально, когда отношение между гиперпараметром и наблюдаемой метрикой гладкая, что позволит исключить выбор некорректного выброса.

**15. Как реализован y_range в fastai? (Посмотрите, сможете ли вы реализовать его самостоятельно и протестировать без пика!)**

*y_range* реализован с помощью *sigmoid_range* в *fastai*.

```python
def sigmoid_range(x, lo, hi): return x.sigmoid() * (hi-lo) + lo
```

**16. Что такое проблема регрессии? Какую функцию потерь вы должны использовать для такой проблемы?**

В регрессионной задаче зависимая переменная или метки, которые мы пытаемся предсказать, являются непрерывными значениями. Для таких задач используется функция среднеквадратичных потерь ошибок.

**17. Что вам нужно сделать, чтобы убедиться, что библиотека fastai применяет одно и то же увеличение данных к вашим входным изображениям и координатам целевой точки?**

Вам нужно использовать правильный DataBlock. В данном случае это PointBlock. Этот DataBlock автоматически применяет увеличение данных к входным изображениям и координатам целевой точки.















**1. Почему мы сначала изменяем размер до большого размера на процессоре, а затем до меньшего размера на графическом процессоре?**

Эта концепция известна как проклеивание (presizing). Прирост данных часто применяется к изображениям, и на самом деле это делается на графическом процессоре. Однако увеличение объема данных может привести к ухудшению качества и появлению артефактов, особенно на краях. Поэтому, чтобы свести к минимуму ухудшение качества данных, дополнения выполняются на более крупном изображении, а затем выполняется RandomResizeCrop изменение размера до требуемого размера изображения.

**2. Если вы не знакомы с регулярными выражениями, найдите учебник по регулярным выражениям и задач и выполните их.**

Выполняется самостоятельно

**3. Каковы два наиболее распространенных способа предоставления данных для большинства наборов данных глубокого обучения?**

* Отдельные файлы, представляющие элементы данных, такие как текстовые документы или изображения.
* Таблица данных, например в формате CSV, где каждая строка является элементом и может включать имена файлов, обеспечивающие связь между данными в таблице и данными в других форматах, таких как текстовые документы и изображения.

**4. Посмотрите документацию на L и попробуйте использовать несколько новых методов.**

Выполняется [самостоятельно](https://fastcore.fast.ai/#L)

**5. Посмотрите документацию для модуля Python pathlib и попробуйте использовать несколько методов класса Path.**

Выполняется [самостоятельно](https://docs.python.org/3/library/pathlib.html)

**6. Приведите два примера того, как преобразования изображений могут ухудшить качество данных.**

* Вращение может являться причиной пустых областей в конечном изображении
* Другие операции могут потребовать интерполяции, которая основана на исходных пикселях изображения и в результате более низкое качество изображения

**7. Какой метод в fastai для просмотра данных в загрузчике данных (DataLoader)?**

DataLoader.show_batch

**8. Какой метод в fastai, чтобы помочь вам отладить DataBlock?**

DataBlock.summary

**9. Следует ли вам отложить обучение модели до тех пор, пока вы не очистите свои данные полностью?**

Нет. Лучше всего первоначально создать базовую модель.

**10. Что за два метода объединены в кросс-энтропию в PyTorch?**

Кросс энтропийные потери представляет собой комбинацию функции Softmax и отрицательной логарифмической потери правдоподобия.

**11. Каковы два свойства активаций, которые гарантирует softmax? Почему это так важно?**

Выходные данные в сумме дают один и модель может предсказать только один класс. Кроме того, усиливаются небольшие изменения в выходных активациях, что полезно, поскольку это означает, что модель выберет метку с более высокой увереностью (хорошо для проблем с конкретными метками).

**12. Когда вы хотите, чтобы ваши активации не имели этих свойств?**

Когда у вас есть проблемы с классификацией нескольких меток (возможно более одной метки).

**13. Вычислите столбцы exp и softmax.**

ПРОПУЩЕНО

**14. Почему мы не можем использовать torch.where для создания функции потерь для наборов данных, где наша метка может иметь более двух категорий?**

Потому что torch.where может выбирать только между двумя возможностями, в то время как для многоклассовой классификации у нас есть необходимость в выборе нескольких вариантов.

**15. Каково значение log (-2)? Почему?**

Значение не определено. Логарифм является обратной экспоненциальной функцией, а экспоненциальная функция всегда положительна, независимо от того, какое значение передается. Таким образом, логарифм не определен для отрицательных значений.

**16. Каковы два хороших эмпирических правила для выбора скорости обучения при использовании искателя скорости обучения?

Любой из этих двух пунктов должен быть использован для скорости обучения:

* на порядок меньше, чем там, где была достигнута минимальная потеря (то есть минимум, деленный на 10)
* последняя точка, где потеря явно уменьшилась.

**17. Какие два шага делает метод fine_tune?**

* Тренирует новую голову (со случайными весами) в течение одной эпохи
* Разморозет все слои и тренирует их все для требуемого количества эпох

**18. Как получить исходный код метода или функции в Jupyter notebook?**

Использовать ?? после функции. Пример: DataBlock.summary??

**19. Что такое дискриминационные показатели обучения?**

Дискриминативные скорости обучения относятся к тренировочному трюку использования различных скоростей обучения для разных слоев модели. Это обычно используется в трансфертном обучении. Идея заключается в том, что при обучении предварительно подготовленной модели вы не хотите резко менять более ранние слои, поскольку она содержит информацию о простых объектах, таких как ребра и формы. Но более поздние слои могут быть изменены немного больше, поскольку они могут содержать информацию о чертах лица или других объектах, которые могут не иметь отношения к вашей задаче. Таким образом, более ранние слои имеют более низкую скорость обучения, а более поздние слои имеют более высокую скорость обучения.

**20. Как объект slice на языке Python интерпретируется при передаче в качестве скорости обучения в fastai?**

Первое значение объекта среза - это скорость обучения для самого раннего слоя, а второе-скорость обучения для последнего слоя. Промежуточные слои будут иметь скорости обучения, которые мультипликативно равноудалены во всем этом диапазоне.

**21. Почему ранняя остановка является плохим выбором при использовании одного цикла тренировок?**

Если используется ранняя остановка, обучение может не успеть достичь более низких значений скорости на графике, что могло бы способствовать совершенствованию модели. Поэтому рекомендуется переучивать модель и выбирать количество эпох исходя из того, где были найдены предыдущие лучшие результаты.

**22. В чем разница между resnet 50 и resnet101?**

Числа 50 и 101 относятся к числу слоев в моделях. Таким образом, ResNet101-это более крупная модель с большим количеством слоев по сравнению с ResNet50. Эти варианты моделей обычно используются, поскольку существуют модели с предварительно подготовленными весами ImageNet.

**23. Что делает to_fp16?**

Это позволяет проводить обучение со смешанной точностью, в котором для ускорения обучения используются менее точные числа.