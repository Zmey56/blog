---
toc: true
layout: post
comments: true
description: Ответы на девятую часть Fast.ai Deep Learning 2020
categories: [markdown, fastai, Russian, Deep Learning]
title: Russian - Fastbook Chapter 9 questionnaire solutions
---
Ответы на русском языке на [вопросы](https://forums.fast.ai/t/fastbook-chapter-9-questionnaire-solutions-wiki/69932) к девятой части курса Deep Learning 2020 на Fast.ai. Если есть притензии к переводу, как и к осталььным частям прошу писать в коментариях - поправлю.

**1. Что такое непрерывная переменная?**

Это понятие относится к числовым переменным, которые имеют непрерывный диапазон значений (например, возраст)

**2. Что такое категориальная переменная?**

Это понятия относится к переменным, которые принимать дискретные значения в соответствие с различными категориями.

**3. Укажите \2 слова, которые используются для возможных значений категориальной переменной.**

Уровни или категории

**4. Что такое “основной слой(dense layer)”?**

Эквивалентно тому, что мы называем линейными слоями.

**5. Как элементы эмбедингов уменьшают использование памяти и ускоряют работу нейронных сетей?**

Особенно для больших наборов данных представление данных в виде one-hot encoded векторов может быть очень неэффективным (а также разбросанным). С другой стороны, использование элементов эмбедингов позволяет данным иметь гораздо более эффективное (плотное) представление данных в памяти. Это также приведет к ускорению работы модели.

**6. Для каких наборов данных особенно полезны элементы эмбендинга?**

Это особенно полезно для наборов данных с объектами, имеющими большое количество элементов (объекты имеют множество возможных категорий). Другие методы часто переобучаются для таких данных.

**7. Каковы два основных семейства алгоритмов машинного обучения?**

* Ансамбль деревьев решений лучше всего подходит для структурированных (табличных) данных
* Многослойные нейронные сети лучше всего подходят для неструктурированных данных (аудио, зрение, текст и т. д.)

**8. Почему некоторые категориальные столбцы нуждаются в особом порядке в своих классах? Как это делается pandas?**

Категории по своей сути могут иметь некоторый порядок, и при использовании set_categories с аргументом ordered=True и переходящий в упорядоченном списке эта информация представлена в DataFrame pandas.

**9. Подведите итог тому, что делает алгоритм дерева решений.**

Основная идея алгоритма дерева решений состоит в том, чтобы определить, как группировать данные на основе “вопросов”, которые мы задаем о данных. То есть мы продолжаем разбивать данные на основе уровней или значений признаков и генерируем прогнозы на основе среднего целевого значения точек данных в этой группе. Вот алгоритм:

* Циклически просматривайте по очереди каждый столбец набора данных
* Для каждого столбца выполните цикл через каждый возможный уровень 
* Попробуйте разделить данные на две группы в зависимости от того, больше или меньше они определенного значения (или если это категориальная переменная, то в зависимости от того, равны они или не равны этой категориальной переменной)
* Найдите среднюю цену продажи для каждой из этих двух групп и посмотрите, насколько она близка к фактической цене продажи каждого из предметов оборудования в этой группе. То есть рассматривайте это как очень простую “модель”, где наши прогнозы-это просто средняя цена продажи группы товаров
* Пройдя по всем столбцам и возможным уровням для каждого из них, выберите точку разделения, которая дала лучшие прогнозы
* Теперь у нас есть две разные группы для наших данных, основанные на этом выбранном разделении. Рассматривайте каждый из них как отдельные наборы данных и найдите лучшее разделение для каждого из них, вернувшись к шагу один для каждой группы
* Продолжайте этот процесс рекурсивно и до тех пор, пока не достигнете некоторого критерия остановки для каждой группы — например, прекратите дальнейшее разделение группы, когда в ней всего 20 элементов.

**10. Почему дата отличается от обычной категориальной или непрерывной переменной и как вы можете предварительно обработать ее, чтобы она могла использоваться в модели?**

Некоторые даты (например, некоторые из них являются праздниками, выходными и т. д.) не могут быть описаны как просто порядковые переменные. Вместо этого мы можем сгенерировать множество различных категориальных признаков о свойствах данной даты (например, это будний день? это конец месяца? и т. д.)

**11. Должны ли вы выбрать случайный проверочный набор в конкурсе бульдозеров? Если нет, то какой набор валидации вы должны выбрать?**

Нет, проверочный набор должен быть максимально похож на тестовый набор. В этом случае тестовый набор содержит данные из более поздних данных, поэтому мы должны разделить данные по датам и включить более поздние даты в набор проверки.

**12. Что такое метод pickle и для чего он полезен?**

Позволяет сохранить практически любой объект Python в виде файла.

**13. Как вычисляются значения в дереве решений?**

Проходя по дереву, основанному на ответе на вопросы о данных, мы достигаем узлов, которые сообщают нам среднее значение данных в этой группе, mse и количество значений в этой группе.

**14.Как мы справляемся с выбросами, прежде чем построить дерево решений?**

Иногда трудно даже понять, распределен ли ваш тестовый набор таким же образом, как и ваши обучающие данные, или, если он отличается, то какие столбцы отражают эту разницу. На самом деле есть очень простой способ понять это, а именно использовать случайный лес!

Но в этом случае мы не используем случайный лес для предсказания нашей фактической зависимой переменной. Вместо этого мы пытаемся предсказать, находится ли строка в наборе проверки или в обучающем наборе.

**15. Как мы обрабатываем категориальные переменные в дереве решений?**

Мы преобразуем категориальные переменные в целые числа, где целые числа соответствуют определенным уровням категориальной переменной. В связи с чем нет ничего сложного, чтобы заставить их работать в деревьях решений (в отличие от нейронных сетей, где мы используем слои встраивания).

**16. Что такое пакетирование (bagging)?**

Обучение несколько моделей на случайных подмножествах данных и использование их ансамбля для прогнозирования.

**17. В чем разница между max_samples и max_features при создании случайного леса?**

При работе со случайными лесами, мы обучаем несколько деревьев решений на случайных подмножествах данных. max_samples определяет сколько мы будем использовать число экземпляров, или строк из табличного DataSet для каждого дерева решений. max_features определяет, сколько признаков, или столбцов из табличного DataSet мы используем для каждого дерева решений.

**18. Если вы увеличите n_estimators до очень высокого значения, может ли это привести к переобучению? Почему или почему нет?**

Более высокие значения n_estimators означают, что используется больше деревьев решений. Однако, поскольку деревья независимы друг от друга, использование более высоких n_estimators не приводит к переобучению.

**19. Что такое out of bag error?**

Это встроенная версия расчёта ошибки теста. Это очень удобно, потому что вам не нужно откладывать набор данных в самом начале. Проверочный набор не требуется.

**20. Составьте список причин, по которым ошибка проверочного набора модели может быть хуже ошибки OOB. Как вы можете проверить свою гипотезу?**

Основная причина может заключаться в том, что модель плохо обобщается. Это связано возможно с тем, что данные проверки имеют несколько иное распределение, чем данные, на которых обучалась модель.

**21. Как вы можете ответить на каждый из этих вопросов случайным лесом? Как они работают?:**

*Насколько мы уверены в своих прогнозах, используя определенный ряд данных?*

Посмотрите на стандартное отклонение между оценками

*Для прогнозирования с помощью определенного ряда данных, каковы были наиболее важные факторы, и как они повлияли на это предсказание?*

Использование пакета treeinterpreter для проверки того, как прогноз изменяется по мере прохождения дерева, суммируя вклады от каждого разделения/функции. Используйте график waterfall для визуализации.

*Какие столбцы являются самыми сильными предсказателями?*

Посмотрите на важность признака

*Как меняются предсказания, когда мы меняем эти столбцы?*

Посмотрите на графики частичной зависимости.

**22. Какова цель удаления неважных переменных?**

Иногда лучше иметь более интерпретируемую модель с меньшим количеством признаков, поэтому удаление неважных переменных помогает в этом отношении.

**23. Что такое хороший тип графика для отображения результатов интерпретатора дерева?**

Waterfall график.

**24. В чем заключается проблема экстраполяции ?**

Модель трудно экстраполировать на данные, которые находятся за пределами области обучающих данных. Это особенно важно для случайных лесов. С другой стороны, нейронные сети имеют лежащие в основе линейные слои, поэтому они потенциально могут лучше обобщать.

**25. Как вы можете определить, распределен ли ваш тестовый или проверочный набор по-другому, чем ваш тренировочный?**

Мы можем сделать это, обучив модель классифицировать, являются ли данные обучающими или проверочными. Если данные имеют различные распределения (out-of-domain данные), то модель может правильно классифицировать между двумя наборами данных.

**26. Почему мы делаем saleElapsed непрерывной переменной, даже если она имеет менее 9000 различных значений?**

Это переменная, которая меняется со временем, и поскольку мы хотим, чтобы наша модель экстраполировалась на будущие результаты, мы делаем ее непрерывной переменной.

**27. Что такое бустинг?**

Мы обучаем модель, которая использует не весь набор данных, и обучаем последующие модели, которые предсказывают ошибку исходной модели. Затем мы добавляем предсказания всех моделей, чтобы получить окончательный прогноз.

**28. Как мы могли бы использовать embeddings со случайным лесом? Будем ли мы ожидать, что это поможет?**

Embeddings содержат более богатые представления категориальных признаков и, безусловно, могут улучшить производительность моделей, таких как случайные леса. Вместо того чтобы передавать необработанные категориальные столбцы, Embeddings могут быть переданы в модель случайного леса.

**29. Почему мы можем не всегда использовать нейронную сеть для табличного моделирования?**

Мы можем не использовать их, потому что их труднее и долше обучать, и они менее понятны. Вместо этого первым выбором должны быть случайные леса, а уже попробовать использовать нейронные сети, чтобы улучшить эти результаты или добавить их в ансамбль.